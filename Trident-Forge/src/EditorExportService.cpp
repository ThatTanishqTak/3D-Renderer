#include "EditorExportService.h"

#include "Core/Utilities.h"

#include <fstream>
#include <iomanip>
#include <sstream>
#include <system_error>
#include <cstdlib>
#include <string_view>
#include <algorithm>
#include <cctype>
#include <vector>

namespace
{
    std::filesystem::path NormalisePath(const std::filesystem::path& path)
    {
        std::error_code l_Error{};
        std::filesystem::path l_Normalised = std::filesystem::weakly_canonical(path, l_Error);
        if (l_Error)
        {
            return path;
        }

        return l_Normalised;
    }

    /**
     * @brief Create a lower-case copy to support case-insensitive comparisons when scanning build folders.
     */
    std::string ToLowerCopy(std::string_view value)
    {
        std::string l_Result(value);
        std::transform(l_Result.begin(), l_Result.end(), l_Result.begin(),
            [](unsigned char character)
            {
                return static_cast<char>(std::tolower(character));
            });
        return l_Result;
    }

    /**
     * @brief Convenience wrapper for checking whether two identifiers match regardless of case.
     */
    bool CaseInsensitiveContains(std::string_view haystack, std::string_view needle)
    {
        if (needle.empty())
        {
            return true;
        }

        const std::string l_HaystackLower = ToLowerCopy(haystack);
        const std::string l_NeedleLower = ToLowerCopy(needle);
        return l_HaystackLower.find(l_NeedleLower) != std::string::npos;
    }

    /**
     * @brief Identify build directories produced by the new CMake presets or legacy scripts.
     *
     * The exporter used to assume Visual Studio projects lived next to the sources. We now probe the
     * generated build tree instead so that exports use the binaries actually produced by cmake --build.
     */
    std::vector<std::filesystem::path> GatherCandidateBuildDirectories(const std::filesystem::path& projectRoot)
    {
        std::vector<std::filesystem::path> l_Candidates{};

        const auto AddCandidate = [&l_Candidates](const std::filesystem::path& candidate)
            {
                std::error_code l_Error{};
                if (candidate.empty() || !std::filesystem::exists(candidate, l_Error) || !std::filesystem::is_directory(candidate, l_Error))
                {
                    return;
                }

                const std::filesystem::path l_Normalised = NormalisePath(candidate);
                if (std::find(l_Candidates.begin(), l_Candidates.end(), l_Normalised) == l_Candidates.end())
                {
                    l_Candidates.emplace_back(l_Normalised);
                }
            };

        // Step 1: scan the build directories created by the official CMake presets.
        const std::filesystem::path l_PresetRoot = projectRoot / "out" / "build";
        AddCandidate(l_PresetRoot);
        std::error_code l_IterationError{};
        for (std::filesystem::directory_iterator it_Build{ l_PresetRoot, l_IterationError }; it_Build != std::filesystem::directory_iterator{}; ++it_Build)
        {
            if (l_IterationError)
            {
                break;
            }

            AddCandidate(it_Build->path());
        }

        // Step 2: include the Build folder generated by Scripts/Build-WIndow.bat for contributors using legacy tooling.
        AddCandidate(projectRoot / "Build");

        // Step 3: keep the historic Trident source directory as an ultimate fallback.
        AddCandidate(projectRoot / "Trident");

        return l_Candidates;
    }

    /**
     * @brief Check whether the provided directory contains enough build artefacts to drive exports.
     */
    bool DirectoryLooksLikeBuildTree(const std::filesystem::path& directory)
    {
        std::error_code l_Error{};
        if (directory.empty() || !std::filesystem::exists(directory, l_Error) || !std::filesystem::is_directory(directory, l_Error))
        {
            return false;
        }

        if (std::filesystem::exists(directory / "CMakeCache.txt", l_Error) || std::filesystem::exists(directory / "build.ninja", l_Error))
        {
            return true;
        }

        if (std::filesystem::exists(directory / "Trident.sln", l_Error) || std::filesystem::exists(directory / "Trident.vcxproj", l_Error))
        {
            return true;
        }

        const std::filesystem::path l_TridentSubdirectory = directory / "Trident";
        if (std::filesystem::exists(l_TridentSubdirectory, l_Error) && std::filesystem::is_directory(l_TridentSubdirectory, l_Error))
        {
            if (std::filesystem::exists(l_TridentSubdirectory / "Trident.sln", l_Error) || std::filesystem::exists(l_TridentSubdirectory / "Trident.vcxproj", l_Error))
            {
                return true;
            }

            if (std::filesystem::exists(l_TridentSubdirectory / "CMakeCache.txt", l_Error) || std::filesystem::exists(l_TridentSubdirectory / "build.ninja", l_Error))
            {
                return true;
            }
        }

        return false;
    }
}

EditorExportService::EditorExportService(std::filesystem::path projectRoot) : m_ProjectRoot(std::move(projectRoot))
{
    m_ProjectRoot = NormalisePath(m_ProjectRoot);
}

void EditorExportService::SetProjectRoot(const std::filesystem::path& projectRoot)
{
    m_ProjectRoot = NormalisePath(projectRoot);
}

EditorExportService::ExportResult EditorExportService::ExportScene(const Trident::Scene& scene,
    const Trident::RuntimeCamera& runtimeCamera,
    const std::filesystem::path& currentScenePath,
    const ExportOptions& options) const
{
    ExportResult l_Result{};

    if (options.m_OutputDirectory.empty())
    {
        l_Result.m_Message = "Select an output directory before exporting.";
        TR_CORE_ERROR("Export aborted because no destination directory was provided.");
        return l_Result;
    }

    std::filesystem::path l_OutputDirectory = NormalisePath(options.m_OutputDirectory);
    std::error_code l_CreateError{};
    std::filesystem::create_directories(l_OutputDirectory, l_CreateError);
    if (l_CreateError)
    {
        std::ostringstream l_Stream;
        l_Stream << "Failed to create export directory '" << l_OutputDirectory.string() << "': " << l_CreateError.message();
        l_Result.m_Message = l_Stream.str();
        TR_CORE_ERROR(l_Result.m_Message);
        return l_Result;
    }

    const std::filesystem::path l_ContentDirectory = l_OutputDirectory / "Content";
    std::filesystem::create_directories(l_ContentDirectory, l_CreateError);
    if (l_CreateError)
    {
        std::ostringstream l_Stream;
        l_Stream << "Failed to create content directory '" << l_ContentDirectory.string() << "': " << l_CreateError.message();
        l_Result.m_Message = l_Stream.str();
        TR_CORE_ERROR(l_Result.m_Message);
        return l_Result;
    }

    std::string l_SceneFileName;
    if (!currentScenePath.empty() && currentScenePath.has_filename())
    {
        l_SceneFileName = currentScenePath.filename().string();
    }
    else
    {
        l_SceneFileName = scene.GetName().empty() ? "ExportedScene.trident" : scene.GetName() + ".trident";
    }

    std::filesystem::path l_SceneOutputPath = l_ContentDirectory / l_SceneFileName;
    if (l_SceneOutputPath.extension() != ".trident")
    {
        l_SceneOutputPath.replace_extension(".trident");
    }

    scene.Save(l_SceneOutputPath.string());
    TR_CORE_INFO("Scene serialised to '{}' for export.", l_SceneOutputPath.string());

    std::string l_CameraMessage;
    if (!WriteRuntimeCameraFile(l_ContentDirectory, runtimeCamera, l_CameraMessage))
    {
        l_Result.m_Message = l_CameraMessage;
        return l_Result;
    }

    std::string l_BuildMessage;
    if (!BuildRuntimeProject(options.m_BuildConfiguration, l_BuildMessage))
    {
        l_Result.m_Message = l_BuildMessage;
        return l_Result;
    }

    std::string l_CopyMessage;
    if (!CopyRuntimeOutputs(l_OutputDirectory, options.m_BuildConfiguration, l_CopyMessage))
    {
        l_Result.m_Message = l_CopyMessage;
        return l_Result;
    }

    std::ostringstream l_Stream;
    l_Stream << "Export complete. Packaged scene written to '" << l_OutputDirectory.string() << "'.";
    if (!l_CameraMessage.empty())
    {
        l_Stream << " " << l_CameraMessage;
    }

    l_Result.m_Succeeded = true;
    l_Result.m_Message = l_Stream.str();
    TR_CORE_INFO("{}", l_Result.m_Message);

    return l_Result;
}

bool EditorExportService::BuildRuntimeProject(const std::string& configuration, std::string& outMessage) const
{
    const std::filesystem::path l_BuildDirectory = ResolveRuntimeBuildDirectory();
    if (l_BuildDirectory.empty())
    {
        outMessage = "Runtime build directory not found. Configure the project with the provided CMake presets.";
        TR_CORE_WARN(outMessage);
        return false;
    }

    const std::filesystem::path l_ProjectFile = ResolveRuntimeProjectFile();
#if defined(_WIN32)
    const std::string l_Configuration = configuration.empty() ? std::string("Debug") : configuration;

    if (!l_ProjectFile.empty())
    {
        const std::string l_Extension = ToLowerCopy(l_ProjectFile.extension().string());
        if (l_Extension == ".sln" || l_Extension == ".vcxproj")
        {
            // Visual Studio generators keep the solution alongside the build tree; reuse msbuild for consistency.
            std::string l_Command = "msbuild \"" + l_ProjectFile.string() + "\"";
            l_Command += " /p:Platform=x64";
            if (!l_Configuration.empty())
            {
                l_Command += " /p:Configuration=" + l_Configuration;
            }

            TR_CORE_INFO("Building runtime via msbuild using '{}'.", l_ProjectFile.string());
            TR_CORE_INFO("Invoking runtime build command: {}", l_Command);

            const int l_Result = std::system(l_Command.c_str());
            if (l_Result != 0)
            {
                std::ostringstream l_Stream;
                l_Stream << "msbuild exited with code " << l_Result << ". Check Visual Studio 2022 installation.";
                outMessage = l_Stream.str();
                TR_CORE_ERROR(outMessage);
                return false;
            }

            outMessage.clear();
            return true;
        }
    }

    // Ninja (preset) builds rely on cmake --build so we default to that path while highlighting the directory we resolved.
    std::string l_Command = "cmake --build \"" + l_BuildDirectory.string() + "\" --target Trident";
    if (!l_Configuration.empty())
    {
        l_Command += " --config " + l_Configuration;
    }

    TR_CORE_INFO("Building runtime via cmake in '{}'.", l_BuildDirectory.string());
    TR_CORE_INFO("Invoking runtime build command: {}", l_Command);

    const int l_Result = std::system(l_Command.c_str());
    if (l_Result != 0)
    {
        std::ostringstream l_Stream;
        l_Stream << "cmake --build exited with code " << l_Result << ". Ensure the preset has been configured successfully.";
        outMessage = l_Stream.str();
        TR_CORE_ERROR(outMessage);
        return false;
    }

    outMessage.clear();
#else
    (void)configuration;
    (void)l_ProjectFile;
    outMessage = "CMake/msbuild automation unavailable on this platform. Copying existing binaries.";
    TR_CORE_WARN(outMessage);
    return false;
#endif

    return true;
}

bool EditorExportService::CopyRuntimeOutputs(const std::filesystem::path& destination, const std::string& configuration, std::string& outMessage) const
{
    const std::filesystem::path l_BinarySource = ResolveRuntimeBinaryDirectory(configuration);
    const std::filesystem::path l_AssetSource = ResolveRuntimeAssetsDirectory();

    if (l_BinarySource.empty() || !std::filesystem::exists(l_BinarySource))
    {
        outMessage = "Runtime binaries were not found. Build the Trident project before exporting.";
        TR_CORE_ERROR(outMessage);
        return false;
    }

    if (l_AssetSource.empty() || !std::filesystem::exists(l_AssetSource))
    {
        outMessage = "Runtime assets directory missing. Ensure Trident/Assets is available.";
        TR_CORE_ERROR(outMessage);
        return false;
    }

    TR_CORE_INFO("Using runtime binaries from '{}' (configuration '{}').", l_BinarySource.string(), configuration.empty() ? "Default" : configuration);
    TR_CORE_INFO("Using runtime assets from '{}'.", l_AssetSource.string());

    const auto CopyDirectory = [](const std::filesystem::path& source, const std::filesystem::path& target, std::string_view description) -> bool
        {
            std::error_code l_Error{};
            std::filesystem::create_directories(target, l_Error);
            if (l_Error)
            {
                std::ostringstream l_Stream;
                l_Stream << "Failed to create " << description << " directory '" << target.string() << "': " << l_Error.message();
                TR_CORE_ERROR(l_Stream.str());
                return false;
            }

            for (std::filesystem::recursive_directory_iterator it_Source{ source, l_Error }; it_Source != std::filesystem::recursive_directory_iterator{}; ++it_Source)
            {
                if (l_Error)
                {
                    std::ostringstream l_Stream;
                    l_Stream << "Failed to enumerate " << description << " files: " << l_Error.message();
                    TR_CORE_ERROR(l_Stream.str());
                    return false;
                }

                const std::filesystem::path l_Relative = std::filesystem::relative(it_Source->path(), source, l_Error);
                if (l_Error)
                {
                    std::ostringstream l_Stream;
                    l_Stream << "Failed to compute relative path for '" << it_Source->path().string() << "': " << l_Error.message();
                    TR_CORE_ERROR(l_Stream.str());
                    return false;
                }

                const std::filesystem::path l_TargetPath = target / l_Relative;
                if (it_Source->is_directory())
                {
                    std::filesystem::create_directories(l_TargetPath, l_Error);
                    if (l_Error)
                    {
                        std::ostringstream l_Stream;
                        l_Stream << "Failed to create directory '" << l_TargetPath.string() << "': " << l_Error.message();
                        TR_CORE_ERROR(l_Stream.str());
                        return false;
                    }
                    continue;
                }

                std::filesystem::create_directories(l_TargetPath.parent_path(), l_Error);
                if (l_Error)
                {
                    std::ostringstream l_Stream;
                    l_Stream << "Failed to create parent directory for '" << l_TargetPath.string() << "': " << l_Error.message();
                    TR_CORE_ERROR(l_Stream.str());
                    return false;
                }

                std::filesystem::copy_file(it_Source->path(), l_TargetPath, std::filesystem::copy_options::update_existing, l_Error);
                if (l_Error)
                {
                    std::ostringstream l_Stream;
                    l_Stream << "Failed to copy '" << it_Source->path().string() << "' to '" << l_TargetPath.string() << "': " << l_Error.message();
                    TR_CORE_ERROR(l_Stream.str());
                    return false;
                }
            }

            return true;
        };

    const std::filesystem::path l_BinaryDestination = destination / "Bin";
    TR_CORE_INFO("Copying runtime binaries into '{}'.", l_BinaryDestination.string());
    if (!CopyDirectory(l_BinarySource, l_BinaryDestination, "runtime binaries"))
    {
        outMessage = "Failed to copy runtime binaries.";
        return false;
    }

    const std::filesystem::path l_AssetDestination = destination / "Assets";
    TR_CORE_INFO("Copying runtime assets into '{}'.", l_AssetDestination.string());
    if (!CopyDirectory(l_AssetSource, l_AssetDestination, "runtime assets"))
    {
        outMessage = "Failed to copy runtime assets.";
        return false;
    }

    outMessage.clear();
    return true;
}

bool EditorExportService::WriteRuntimeCameraFile(const std::filesystem::path& contentDirectory,
    const Trident::RuntimeCamera& runtimeCamera,
    std::string& outMessage) const
{
    const std::filesystem::path l_CameraFile = contentDirectory / "runtime_camera.txt";
    std::ofstream l_Stream(l_CameraFile, std::ios::trunc);
    if (!l_Stream.is_open())
    {
        outMessage = "Unable to write runtime camera description.";
        TR_CORE_ERROR("Failed to open '{}' for writing runtime camera data.", l_CameraFile.string());
        return false;
    }

    const glm::vec3 l_Position = runtimeCamera.GetPosition();
    const glm::vec3 l_Rotation = runtimeCamera.GetRotation();

    l_Stream << "# Trident Runtime Camera Export\n";
    l_Stream << std::setprecision(9);
    l_Stream << "Position " << l_Position.x << ' ' << l_Position.y << ' ' << l_Position.z << "\n";
    l_Stream << "Rotation " << l_Rotation.x << ' ' << l_Rotation.y << ' ' << l_Rotation.z << "\n";

    outMessage = "Runtime camera transform captured.";
    return true;
}

std::filesystem::path EditorExportService::ResolveRuntimeBuildDirectory() const
{
    // Walk through the candidates and return the first directory that exposes build artefacts.
    const std::vector<std::filesystem::path> l_Candidates = GatherCandidateBuildDirectories(m_ProjectRoot);
    for (const std::filesystem::path& l_CandidateRoot : l_Candidates)
    {
        if (DirectoryLooksLikeBuildTree(l_CandidateRoot))
        {
            return l_CandidateRoot;
        }

        const std::filesystem::path l_TridentSubdirectory = l_CandidateRoot / "Trident";
        if (DirectoryLooksLikeBuildTree(l_TridentSubdirectory))
        {
            return l_TridentSubdirectory;
        }
    }

    // TODO: cache the resolved directory per session to avoid repeated filesystem probes once exports are frequent.
    return {};
}

std::filesystem::path EditorExportService::ResolveRuntimeProjectFile() const
{
    const std::filesystem::path l_BuildDirectory = ResolveRuntimeBuildDirectory();
    std::error_code l_Error{};
    if (!l_BuildDirectory.empty())
    {
        // Inspect the discovered build tree for generated solutions or project files.
        const std::vector<std::filesystem::path> l_ProjectFiles =
        {
            l_BuildDirectory / "Trident.sln",
            l_BuildDirectory / "Trident.vcxproj",
            l_BuildDirectory / "Trident" / "Trident.sln",
            l_BuildDirectory / "Trident" / "Trident.vcxproj"
        };

        for (const std::filesystem::path& l_Candidate : l_ProjectFiles)
        {
            if (std::filesystem::exists(l_Candidate, l_Error))
            {
                return l_Candidate;
            }

            l_Error.clear();
        }
    }

    // Keep the legacy behaviour as an emergency fallback for older check-outs.
    const std::filesystem::path l_Solution = m_ProjectRoot / "Trident" / "Trident.sln";
    if (std::filesystem::exists(l_Solution, l_Error))
    {
        return l_Solution;
    }

    l_Error.clear();
    const std::filesystem::path l_Project = m_ProjectRoot / "Trident" / "Trident.vcxproj";
    if (std::filesystem::exists(l_Project, l_Error))
    {
        return l_Project;
    }

    return {};
}

std::filesystem::path EditorExportService::ResolveRuntimeBinaryDirectory(const std::string& configuration) const
{
    const std::filesystem::path l_BuildDirectory = ResolveRuntimeBuildDirectory();
    const std::string l_Configuration = configuration.empty() ? std::string("Debug") : configuration;

    std::vector<std::filesystem::path> l_Candidates{};

    if (!l_BuildDirectory.empty())
    {
        // Prefer binaries inside the configured build tree.
        l_Candidates.emplace_back(l_BuildDirectory / "Trident");
        l_Candidates.emplace_back(l_BuildDirectory / l_Configuration / "Trident");

        const std::filesystem::path l_PresetCandidate = l_BuildDirectory / ("Windows-" + l_Configuration + "-x64") / "Trident";
        l_Candidates.emplace_back(l_PresetCandidate);
    }

    // Fall back to the shared bin folder configured in cmake/Tooling.cmake.
    const std::filesystem::path l_BinRoot = m_ProjectRoot / "bin";
    std::error_code l_Error{};
    if (std::filesystem::exists(l_BinRoot, l_Error))
    {
        const std::filesystem::path l_DefaultBin = l_BinRoot / ("Windows-" + l_Configuration + "-x64") / "Trident";
        l_Candidates.emplace_back(l_DefaultBin);

        l_Error.clear();
        for (std::filesystem::directory_iterator it_Bin{ l_BinRoot, l_Error }; it_Bin != std::filesystem::directory_iterator{}; ++it_Bin)
        {
            if (l_Error)
            {
                break;
            }

            if (!it_Bin->is_directory())
            {
                continue;
            }

            const std::string l_Name = it_Bin->path().filename().string();
            if (CaseInsensitiveContains(l_Name, l_Configuration))
            {
                l_Candidates.emplace_back(it_Bin->path() / "Trident");
            }
        }
    }

    // Maintain the old Trident/bin fallback for non-preset layouts.
    l_Candidates.emplace_back(m_ProjectRoot / "Trident" / "bin" / l_Configuration);
    l_Candidates.emplace_back(m_ProjectRoot / "Trident" / "bin");

    for (const std::filesystem::path& l_Candidate : l_Candidates)
    {
        if (l_Candidate.empty())
        {
            continue;
        }

        if (std::filesystem::exists(l_Candidate, l_Error))
        {
            return NormalisePath(l_Candidate);
        }

        l_Error.clear();
    }

    return {};
}

std::filesystem::path EditorExportService::ResolveRuntimeAssetsDirectory() const
{
    return m_ProjectRoot / "Trident" / "Assets";
}